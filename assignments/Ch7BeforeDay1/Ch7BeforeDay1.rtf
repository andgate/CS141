{\rtf1\ansi\deff3\adeflang1025
{\fonttbl{\f0\froman\fprq2\fcharset0 Times New Roman;}{\f1\froman\fprq2\fcharset2 Symbol;}{\f2\fswiss\fprq2\fcharset0 Arial;}{\f3\froman\fprq2\fcharset0 Liberation Serif{\*\falt Times New Roman};}{\f4\fswiss\fprq2\fcharset0 Liberation Sans{\*\falt Arial};}{\f5\froman\fprq0\fcharset128 Monospaced.plain;}{\f6\fnil\fprq2\fcharset0 DejaVu Sans;}{\f7\fnil\fprq2\fcharset0 Lohit Hindi;}{\f8\fnil\fprq0\fcharset128 Lohit Hindi;}}
{\colortbl;\red0\green0\blue0;\red148\green30\blue223;\red0\green203\blue0;\red128\green128\blue128;}
{\stylesheet{\s0\snext0\nowidctlpar{\*\hyphen2\hyphlead2\hyphtrail2\hyphmax0}\cf0\kerning1\dbch\af6\langfe2052\dbch\af7\afs24\alang1081\loch\f3\fs24\lang1033 Normal;}
{\*\cs15\snext15 Numbering Symbols;}
{\s16\sbasedon0\snext17\sb240\sa120\keepn\dbch\af6\dbch\af7\afs28\loch\f4\fs28 Heading;}
{\s17\sbasedon0\snext17\sl288\slmult1\sb0\sa140 Text Body;}
{\s18\sbasedon17\snext18\sl288\slmult1\sb0\sa140\dbch\af8 List;}
{\s19\sbasedon0\snext19\sb120\sa120\noline\i\dbch\af8\afs24\ai\fs24 Caption;}
{\s20\sbasedon0\snext20\noline\dbch\af8 Index;}
}{\info{\creatim\yr2014\mo11\dy9\hr2\min5}{\revtim\yr2014\mo11\dy9\hr2\min26}{\printim\yr0\mo0\dy0\hr0\min0}{\comment LibreOffice}{\vern67241475}}\deftab720
\viewscale100
{\*\pgdsctbl
{\pgdsc0\pgdscuse451\pgwsxn12240\pghsxn15840\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\pgdscnxt0 Default Style;}}
\formshade\paperh15840\paperw12240\margl1134\margr1134\margt1134\margb1134\sectd\sbknone\sectunlocked1\pgndec\pgwsxn12240\pghsxn15840\marglsxn1134\margrsxn1134\margtsxn1134\margbsxn1134\ftnbj\ftnstart1\ftnrstcont\ftnnar\aenddoc\aftnrstcont\aftnstart1\aftnnrlc
\pgndec\pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\rtlch \ltrch\loch
Gabriel Anderson\line Chapter 7 Before Day 1, }{\rtlch \ltrch\loch
Self-Check problems}{\rtlch \ltrch\loch
\line CS&141, S1\line }
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
1. }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
[] primes = \{ 1, 2, 3, 5, 7\};}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
2. }{\ulnone\ulc0\rtlch \ltrch\loch
1 2 3 2 1}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
3. 2 3 4 6 8}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
4. int[] values = new int}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
5.     }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 LOWEST_INDEX = 0;}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 HIGHEST_INDEX = values.length - 1;}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 values[LOWEST_INDEX] = 10;}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 values[HIGHEST_INDEX] = 10;}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
6.}{\cf1\ulnone\ulc0\rtlch \ltrch\loch\fs24\loch\f5
 }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
String[] answers = \{ }{\cf3\rtlch \ltrch\loch\fs24\loch\f5
"Yes"}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
, }{\cf3\rtlch \ltrch\loch\fs24\loch\f5
"No"}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 \};}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
7. No it's not possible using an algorithm similar to the one in section 6.7.5. This is because that algorithm does not save them. You would have to invent a very different algorithm to save the input as a string, and then an algorithm to find the index of the largest number, and then an algorithm to mark the number contained in the index. That's at least three different algorithms to do what is very simple with arrays. So you can't just store the largest and print that one out, like in the given algorithm.\line }
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
8. }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
[] generateLotteryNumbers(}{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 n) \{\}}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
9. Counts the number of zeros the array holds by iterating through each element in the list,}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
and increasing the counter for each element that is equivalent to zero.}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
10. }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
for}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
(}{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 value : values)}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
      \{}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
         System.out.print(value + }{\cf3\rtlch \ltrch\loch\fs24\loch\f5
" "}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
);}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
      \}}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
11. }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 product = 0;}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
      }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
for}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
(}{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 factor : factors)}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
      \{}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
         product *= factor;}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
      \}}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
12. The enhanced for-loop has no index. A basic loop that does \uc2 \u8220\'81\'67values[i] = i*i;\u8221\'81\'68 needs to have a counter to know which element in the array to access.\line \uc1 }
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
13. \tab 20 <== Largest Value}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
\tab 10}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
\tab 20 <== Largest Value}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
\line 14. \tab }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 counter = 0;}{\rtlch \ltrch\loch
\line \tab }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
for}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
(}{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 element : values)}{\rtlch \ltrch\loch
\line \tab }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
\{}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
   \tab \tab }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
if}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
(element == 0) \{ counter++; \}}{\rtlch \ltrch\loch
\line \tab }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
\}}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
15. Because an array of negative numbers would end up not having the largest number marked. This is no good. Instead, the first number in the array is used to initialize largest. At the start of the loop, the largest number is currently the first element in the array, so continue checked from the second element onwards. Therefore, \uc2 \u8220\'81\'67i\u8221\'81\'68 needs to be initialized by 1, which corresponds to the second element. The loop can then go on check the rest of the elements in the array.\uc1 }
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
16. \line }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
for}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 (}{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 i = 0; i < values.length; i++)}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
\{}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
   }{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
   System.out.print(values[i]);}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
  }{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
   }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
if}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 (i < (values.length - 1))}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
   \{}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
      System.out.print(}{\cf3\rtlch \ltrch\loch\fs24\loch\f5
" | "}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
);}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
   \}}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
\}}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
17. This throws an }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
ArrayIndexOutOfBoundsException }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
for arrays with no elements. It would be better to write it this way.\line }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
for}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 (}{\cf2\rtlch \ltrch\loch\fs24\loch\f5
int}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
 i = 0; i < values.length; i++)}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
\{}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
   System.out.print(values[i]);}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
   }{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
  }{\cf2\rtlch \ltrch\loch\fs24\loch\f5
if}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
(i < values.length - 1)}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
   \{}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
      System.out.print(}{\cf3\rtlch \ltrch\loch\fs24\loch\f5
", "}{\cf1\rtlch \ltrch\loch\fs24\loch\f5
);}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
   \}}{\rtlch \ltrch\loch
\line }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
\}}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
18. This loop will only search for values higher than 100, and the original algorithm searched for values equal to 100. Still, there is nothing wrong with using a for loop. It's a matter of choice, and works either way.}
\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0\rtlch \ltrch\loch

\par \pard\plain \s17\sl288\slmult1\sb0\sa140\sb0\sa0{\ulnone\ulc0\rtlch \ltrch\loch
19.  }{\ulnone\ulc0\rtlch \ltrch\loch
This way will throw an }{\cf1\rtlch \ltrch\loch\fs24\loch\f5
ArrayIndexOutOfBoundsException}{\ulnone\ulc0\rtlch \ltrch\loch
 when the currentSize is one less than the size of the array. \uc2 \u8220\'81\'67i\u8221\'81\'68 is guarenteed to be at least one less than the array's actual size, so exceeding i+1 is dangerous and results in  the exception given the array is about to fill up.\uc1 }
\par }